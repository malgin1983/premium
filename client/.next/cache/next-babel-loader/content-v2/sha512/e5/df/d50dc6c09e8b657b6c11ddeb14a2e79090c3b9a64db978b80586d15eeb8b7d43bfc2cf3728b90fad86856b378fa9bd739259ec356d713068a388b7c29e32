{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { useEffect, useRef } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nexport const useForm = defaultValues => handler => async event => {\n  event.preventDefault();\n  event.persist();\n  const form = event.target;\n  const elements = Array.from(form.elements);\n  const data = elements.filter(element => element.hasAttribute('name')).reduce((object, element) => _objectSpread(_objectSpread({}, object), {}, {\n    [`${element.getAttribute('name')}`]: element.value\n  }), defaultValues);\n  await handler(data);\n  form.reset();\n}; // https://overreacted.io/making-setinterval-declarative-with-react-hooks/\n\nexport const useInterval = (callback, delay) => {\n  const savedCallback = useRef();\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n  useEffect(() => {\n    const handler = (...args) => {\n      var _savedCallback$curren;\n\n      return (_savedCallback$curren = savedCallback.current) === null || _savedCallback$curren === void 0 ? void 0 : _savedCallback$curren.call(savedCallback, ...args);\n    };\n\n    if (delay !== null) {\n      const id = setInterval(handler, delay);\n      return () => clearInterval(id);\n    }\n  }, [delay]);\n}; // Use throughout your app instead of plain `useDispatch` and `useSelector`\n\nexport const useAppDispatch = () => useDispatch();\nexport const useAppSelector = useSelector;","map":{"version":3,"sources":["/Users/a18407633/Documents/Next/client/src/app/hooks.ts"],"names":["useEffect","useRef","useDispatch","useSelector","useForm","defaultValues","handler","event","preventDefault","persist","form","target","elements","Array","from","data","filter","element","hasAttribute","reduce","object","getAttribute","value","reset","useInterval","callback","delay","savedCallback","current","args","id","setInterval","clearInterval","useAppDispatch","useAppSelector"],"mappings":";;;;;;AACA,SAASA,SAAT,EAAoBC,MAApB,QAAkC,OAAlC;AACA,SAA+BC,WAA/B,EAA4CC,WAA5C,QAA+D,aAA/D;AAIA,OAAO,MAAMC,OAAO,GAAcC,aAAX,IACrBC,OAD4D,IAEzD,MAAOC,KAAP,IAA+C;AAClDA,EAAAA,KAAK,CAACC,cAAN;AACAD,EAAAA,KAAK,CAACE,OAAN;AAEA,QAAMC,IAAI,GAAGH,KAAK,CAACI,MAAnB;AACA,QAAMC,QAAQ,GAAGC,KAAK,CAACC,IAAN,CAAWJ,IAAI,CAACE,QAAhB,CAAjB;AACA,QAAMG,IAAI,GAAGH,QAAQ,CAClBI,MADU,CACFC,OAAD,IAAaA,OAAO,CAACC,YAAR,CAAqB,MAArB,CADV,EAEVC,MAFU,CAGT,CAACC,MAAD,EAASH,OAAT,qCACKG,MADL;AAEE,KAAE,GAAEH,OAAO,CAACI,YAAR,CAAqB,MAArB,CAA6B,EAAjC,GAAqCJ,OAAO,CAACK;AAF/C,IAHS,EAOTjB,aAPS,CAAb;AASA,QAAMC,OAAO,CAACS,IAAD,CAAb;AACAL,EAAAA,IAAI,CAACa,KAAL;AACD,CAnBM,C,CAqBP;;AACA,OAAO,MAAMC,WAAW,GAAG,CAACC,QAAD,EAAqBC,KAArB,KAAuC;AAChE,QAAMC,aAAa,GAAG1B,MAAM,EAA5B;AACAD,EAAAA,SAAS,CAAC,MAAM;AACd2B,IAAAA,aAAa,CAACC,OAAd,GAAwBH,QAAxB;AACD,GAFQ,EAEN,CAACA,QAAD,CAFM,CAAT;AAGAzB,EAAAA,SAAS,CAAC,MAAM;AACd,UAAMM,OAAO,GAAG,CAAC,GAAGuB,IAAJ;AAAA;;AAAA,sCAAkBF,aAAa,CAACC,OAAhC,0DAAkB,2BAAAD,aAAa,EAAW,GAAGE,IAAd,CAA/B;AAAA,KAAhB;;AAEA,QAAIH,KAAK,KAAK,IAAd,EAAoB;AAClB,YAAMI,EAAE,GAAGC,WAAW,CAACzB,OAAD,EAAUoB,KAAV,CAAtB;AACA,aAAO,MAAMM,aAAa,CAACF,EAAD,CAA1B;AACD;AACF,GAPQ,EAON,CAACJ,KAAD,CAPM,CAAT;AAQD,CAbM,C,CAeP;;AACA,OAAO,MAAMO,cAAc,GAAG,MAAM/B,WAAW,EAAxC;AAEP,OAAO,MAAMgC,cAA8C,GAAG/B,WAAvD","sourcesContent":["import type { ChangeEvent } from 'react'\nimport { useEffect, useRef } from 'react'\nimport { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux'\n\nimport type { AppDispatch, AppState } from './store'\n\nexport const useForm = <TContent>(defaultValues: TContent) => (\n  handler: (content: TContent) => void\n) => async (event: ChangeEvent<HTMLFormElement>) => {\n  event.preventDefault()\n  event.persist()\n\n  const form = event.target as HTMLFormElement\n  const elements = Array.from(form.elements) as HTMLInputElement[]\n  const data = elements\n    .filter((element) => element.hasAttribute('name'))\n    .reduce(\n      (object, element) => ({\n        ...object,\n        [`${element.getAttribute('name')}`]: element.value,\n      }),\n      defaultValues\n    )\n  await handler(data)\n  form.reset()\n}\n\n// https://overreacted.io/making-setinterval-declarative-with-react-hooks/\nexport const useInterval = (callback: Function, delay: number) => {\n  const savedCallback = useRef<Function>()\n  useEffect(() => {\n    savedCallback.current = callback\n  }, [callback])\n  useEffect(() => {\n    const handler = (...args: any) => savedCallback.current?.(...args)\n\n    if (delay !== null) {\n      const id = setInterval(handler, delay)\n      return () => clearInterval(id)\n    }\n  }, [delay])\n}\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>()\n\nexport const useAppSelector: TypedUseSelectorHook<AppState> = useSelector\n"]},"metadata":{},"sourceType":"module"}